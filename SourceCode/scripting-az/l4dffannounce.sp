/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <multicolors>

public Plugin:myinfo = 
{
	name = "L4D FF Announce Plugin",
	author = "Frustian",
	description = "Adds Friendly Fire Announcements + pig survivor notify",
	version = "1.8",
	url = ""
}
//cvar handles
new Handle:FFenabled;
new Handle:AnnounceType
//Various global variables
new DamageCache[MAXPLAYERS+1][MAXPLAYERS+1]; //Used to temporarily store Friendly Fire Damage between teammates
new Handle:FFTimer[MAXPLAYERS+1]; //Used to be able to disable the FF timer when they do more FF
new bool:FFActive[MAXPLAYERS+1]; //Stores whether players are in a state of friendly firing teammates
static bool:ClientHasDown[MAXPLAYERS + 1];
static bool:ClientGrabLedge[MAXPLAYERS + 1];
native bool:IsTankPounchClient(client);//From l4d_tankpunchstuckfix

native IsInReady();
public OnPluginStart()
{
	LoadTranslations("Roto2-AZ_mod.phrases");
	CreateConVar("l4d_ff_announce_version", "1.4", "FF announce Version",FCVAR_SPONLY|FCVAR_NOTIFY);
	FFenabled = CreateConVar("l4d_ff_announce_enable", "1", "Enable Announcing Friendly Fire",FCVAR_SPONLY|FCVAR_NOTIFY);
	AnnounceType = CreateConVar("l4d_ff_announce_type", "1", "Changes how ff announce displays FF damage (1:In chat; 2: In Hint Box; 3: In center text)",FCVAR_SPONLY);
	HookEvent("player_hurt_concise", Event_HurtConcise, EventHookMode_Post);
	HookEvent("player_death", Event_PlayerDeath);
	HookEvent("round_start", Event_RoundStart)
	HookEvent("player_ledge_grab", Event_ledge_grab);
	HookEvent("revive_success", Event_revive_success);//救起倒地的or 懸掛的
	HookEvent("player_bot_replace", OnBotSwap);
	HookEvent("bot_player_replace", OnBotSwap);
	HookEvent("player_spawn", OnPlayerSpawn);
}

public Action:Event_RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	for(new i = 1; i <= MaxClients; i++) 
	{
		ClientHasDown[i] = false;	
		ClientGrabLedge[i] = false;	
	}
}

public Event_PlayerDeath(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	if ( victim == 0 || !IsClientConnected(victim)||!IsClientInGame(victim)) return;
	
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	
	decl String:weapon[15];
	GetEventString(event, "weapon", weapon, sizeof(weapon));
	
	decl String:victimName[128];
	GetClientName(victim,victimName,128);
	//CPrintToChatAll("attacker: %d - victim: %d - weapon: %s",attacker,victim,weapon);
	if(attacker == 0 && !IsWitch(GetEventInt(event, "attackerentid")) && GetClientTeam(victim) == 2 && !ClientHasDown[victim]) //倒地不算了
	{
		if(ClientGrabLedge[victim])//掛邊
		{
			for (new i = 1; i < MaxClients; i++)
				if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i) && (GetClientTeam(i) == 1 || GetClientTeam(i) == 2))
					CPrintToChat(i,"{default}[{olive}TS{default}] %T","fell from top floor.",i,victimName);
		}
		else if (StrEqual(weapon,"infected")) //普通感染者抓死
			return;
		else
			CreateTimer(1.0,Timer_CheckPunch,victim);
	}	
	
	if (attacker == 0 ||!IsClientConnected(attacker) || !IsClientInGame(attacker) ) return;
	decl String:attackerName[128];
	GetClientName(attacker,attackerName,128);
	if(GetClientTeam(attacker) == 2 ) //人類 kill
	{
		if(GetClientTeam(victim) == 2 && victim != attacker)//友傷
		{
			for (new i = 1; i < MaxClients; i++)
				if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i) && (GetClientTeam(i) == 1 || GetClientTeam(i) == 2))
					CPrintToChat(i,"{default}[{olive}TS{default}] %T","player kill teammate",i,attackerName, victimName);
		}
	}	
}

public Action: Timer_CheckPunch(Handle:hTimer, any:client)
{
	if(!IsClientConnected(client)||!IsClientInGame(client)) return;
	
	decl String:clientName[128];
	GetClientName(client,clientName,128);
	if(IsTankPounchClient(client))
		CPrintToChatAll("{green}[TS] %t","Tank Punch survivor fly away and die",clientName);
	else if(!IsFakeClient(client))
		CPrintToChatAll("{green}[TS] {olive}%N{default} : %t",client,"Survivor suicides");
}

public Action:Event_HurtConcise(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	
	new attacker = GetEventInt(event, "attackerentid");
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	if(attacker ==0 && IsClientConnected(victim) && IsClientInGame(victim) && GetClientTeam(victim) == 2)
	{
		if(GetEntProp(victim, Prop_Send, "m_isHangingFromLedge"))
		{
			return;
		}
		if(IsIncapacitated(victim)) 
		{
			CreateTimer(1.0,COLD_DOWN,victim);
		}
	}
	
	if (!GetConVarInt(FFenabled) || attacker > MaxClients || attacker < 1 || !IsClientConnected(attacker) || !IsClientInGame(attacker) || IsFakeClient(attacker) || GetClientTeam(attacker) != 2 || !IsClientInGame(victim) || !IsClientConnected(victim) || GetClientTeam(victim) != 2)
		return;  //if director_ready_duration is 0, it usually means that the game is in a ready up state like downtown1's ready up mod.  This allows me to disable the FF messages in ready up.
	new damage = GetEventInt(event, "dmg_health");
	if (FFActive[attacker])  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		new Handle:pack;
		DamageCache[attacker][victim] += damage;
		KillTimer(FFTimer[attacker]);
		FFTimer[attacker] = CreateDataTimer(1.0, AnnounceFF, pack);
		WritePackCell(pack,attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		new Handle:pack;
		FFActive[attacker] = true;
		FFTimer[attacker] = CreateDataTimer(1.0, AnnounceFF, pack);
		WritePackCell(pack,attacker);
		for (new i = 1; i < 19; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

public Action:COLD_DOWN(Handle:timer,any:victim)
{
	if(!IsClientConnected(victim)||!IsClientInGame(victim)) return;
	if(IsPlayerAlive(victim) && IsIncapacitated(victim)) 
	{
		ClientHasDown[victim] = true;
	}
}

public Action:AnnounceFF(Handle:timer, Handle:pack) //Called if the attacker did not friendly fire recently, and announces all FF they did
{
	decl String:victim[128];
	decl String:attacker[128];
	ResetPack(pack);
	new attackerc = ReadPackCell(pack);
	FFActive[attackerc] = false;
	if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
		GetClientName(attackerc, attacker, sizeof(attacker));
	else
		attacker = "Disconnected Player";
	for (new i = 1; i < MaxClients; i++)
	{
		if (DamageCache[attackerc][i] != 0 && attackerc != i)
		{
			if (IsClientInGame(i) && IsClientConnected(i))
			{
				GetClientName(i, victim, sizeof(victim));
				switch(GetConVarInt(AnnounceType))
				{
					case 1:
					{
						if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
							CPrintToChat(attackerc, "[{olive}TS{default}] %T","l4dffannounce1",attackerc,DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i))
							CPrintToChat(i, "[{olive}TS{default}] %T","l4dffannounce2",i,attacker,DamageCache[attackerc][i]);
					}
					case 2:
					{
						if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
							PrintHintText(attackerc, "%T","l4dffannounce13",attackerc,DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i))
							PrintHintText(i, "%T","l4dffannounce14",i,attacker,DamageCache[attackerc][i]);
					}
					case 3:
					{
						if (IsClientInGame(attackerc) && IsClientConnected(attackerc) && !IsFakeClient(attackerc))
							PrintCenterText(attackerc, "%T","l4dffannounce13",attackerc,DamageCache[attackerc][i],victim);
						if (IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i))
							PrintCenterText(i, "%T","l4dffannounce14",i,attacker,DamageCache[attackerc][i]);
					}
				}
			}
			DamageCache[attackerc][i] = 0;
		}
	}
}

public Event_ledge_grab(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	ClientGrabLedge[client] = true;
}

public Event_revive_success(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	
	new subject = GetClientOfUserId(GetEventInt(event, "subject"));//被救的那位
	if (subject<=0||!IsClientAndInGame(subject)) { return; } //just in case
	
	if (GetEventBool(event,"ledge_hang"))
	{
		ClientGrabLedge[subject] = false;
		return;
	}
	ClientHasDown[subject] = false;
}

public Action:OnBotSwap(Handle:event, const String:name[], bool:dontBroadcast) 
{
	if(IsInReady()) return Plugin_Continue;
	
	new bot = GetClientOfUserId(GetEventInt(event, "bot"));
	new player = GetClientOfUserId(GetEventInt(event, "player"));
	if (IsClientIndex(bot) && IsClientIndex(player)) 
	{
		if (StrEqual(name, "player_bot_replace")) 
		{
			ClientGrabLedge[bot] = ClientGrabLedge[player];
			ClientGrabLedge[player] = false;
			ClientHasDown[bot] = ClientHasDown[player];
			ClientHasDown[player] = false;
			
		}
		else 
		{
			ClientGrabLedge[player] = ClientGrabLedge[bot];
			ClientGrabLedge[bot] = false;
			ClientHasDown[player] = ClientHasDown[bot];
			ClientHasDown[bot] = false;
		}
	}
	return Plugin_Continue;
}

public Action:OnPlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(IsInReady()) return;
	
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(IsClientIndex(client)&&IsClientConnected(client)&&IsClientInGame(client)&&GetClientTeam(client)==2)
	{
		ClientGrabLedge[client] = false;
		ClientHasDown[client] = false;
	}
}

bool:IsClientIndex(client)
{
	return (client > 0 && client <= MaxClients);
}

stock IsIncapacitated(client)
{
	return GetEntProp(client, Prop_Send, "m_isIncapacitated");
}

stock IsClientAndInGame(client)
{
	if (0 < client && client <= MaxClients)
	{	
		return IsClientInGame(client);
	}
	return false;
}

bool IsWitch(int entity)
{
    if (entity > 0 && IsValidEntity(entity) && IsValidEdict(entity))
    {
        static char strClassName[64];
        GetEdictClassname(entity, strClassName, sizeof(strClassName));
        return strcmp(strClassName, "witch", false) == 0;
    }
    return false;
}